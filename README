# **XV6-RISCV: Memory Mapping & `munmap()` Extension Project**

## **Overview**

This project extends the **xv6-riscv** operating system by adding support for **memory mapping (`mmap`)** and **unmapping (`munmap`)** at the user level and kernel level.
The goal is to implement a Linux-like interface that lets user programs request memory regions backed by files or anonymous memory, and safely release them later.

This project was done as part of the OS course final assignment.


## **What I Added / Implemented**

### **1. `mmap()` System Call**

A new system call that allows a user program to map a file or anonymous memory into its address space.

Includes:

* Support for **anonymous** and **file-backed** mappings
* Support for protections (`PROT_READ`, `PROT_WRITE`, etc.)
* Creation and management of **VMA (Virtual Memory Area)** entries
* On-demand lazy allocation of physical pages

### **2. `munmap()` System Call**

Allows unmapping of previously mapped memory regions.

Covers:

* Partial + full unmapping
* Handling dirty pages (writeback if required)
* Splitting / adjusting VMA regions
* Page table cleanup

### **3. Modifications in the Kernel**

Key kernel components updated:

#### `proc.c` / `proc.h`

* Added VMA table inside `struct proc`
* Cleanup of VMA regions during `exec()` and process exit

#### `mmap.c` (new file)

* Core logic for mapping + unmapping memory
* VMA creation, deletion, merging, splitting
* Lazy allocation logic

#### `vm.c`

* Page table operations for mapped regions
* Helper to load pages on fault
* Fixes for copy-on-write + fork handling

#### `trap.c`

* Added page fault handling for mmap regions

#### `syscall.c` / `sysfile.c`

* Added syscall numbers + argument parsing

#### `syscall.h`

* Declared syscall numbers for `mmap` + `munmap`

#### **Makefile**

* Added `kernel/mmap.o` to build list
* Ensured virtio disk is loaded correctly
* Updated user programs

## **Test Programs**

I added small user-level tests to confirm:

* Mapping a file and reading its contents
* Mapping anonymous memory and writing to it
* Partial unmappings
* Fork behavior with mapped regions

Example test file:

user/_testmmap
user/_testmmfork

## **Directory Additions**

kernel/
    mmap.c        
user/
    testmmap.c     
    testmmfork.c

## ⚙️ **Build & Run**

To build everything:

make clean
make qemu

If using manual QEMU run:

qemu-system-riscv64 -machine virt -m 512M -nographic -bios none \
    -kernel kernel/kernel \
    -drive file=fs.img,if=none,format=raw,id=x0 \
    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

## **Notes**

* The virtio disk must be correctly passed; otherwise the kernel will panic.
* All VMA logic is cleaned during process exit and `exec()`.
* `do_mmap()` and `do_munmap()` follow simplified Linux logic but adapted for xv6.


